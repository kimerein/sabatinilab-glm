import numpy as np
import pandas as pd

'''reference new_make_design_mat.ipynb for funciton/build testing grounds'''

def classify_lick_state(timeseries, state):
    
    '''
    define discrete categories of licks such that each lick is mutually exclusively labeled by its state;
    new columns populated by interaction between (1) state, and (2) presence of a lick
    ARGUMENTS:
        - timeseries (pandas DF): timeseries of aligned behavior and photometry data
        - state (list of str): each element of list is string (column header) corresponding to state for lick classification
                               Note: states not listed will result in licks discarded from matrix
    OUTPUT:
        - t_ (pandas DF): copied from `timeseries` input, containing N=len(state) new columns 
    '''
    
    t_ = timeseries.copy()
    for s in state:
        t_[f'{s[:3].lower()}_lick'] = t_[s] * t_['Lick'] # new column containing lick events within each state

    return t_


def pull_lick_from_bout(timeseries, lick_pos, state='Consumption', keep_only_nth_lick=False):
    
    '''split off single lick from lick bout (typically first lick)
    ARGUMENTS:
        - timeseries (pandas DF): timeseries of aligned behavior and photometry data; expects licks labeled in states
        - lick_pos (list): starting at 1 for column labeling (will adjust for 0 indexing)
        - state (str): will only apply function to licks within designated state (might only ever be "Consumption" 
                       because assumes bout)
        - keep_only_nth_lick (bool): if True, drop rest of lick bout (original column); if False, original column 
                                     contains remaining licks only (no duplicates across columns) 

    OUTPUTS:
        - t_ (pandas DF): copied from `timeseries`, with new columns for each lick in `lick_pos` (N=len(lick_pos))
                          minus 1*`keep_only_nth_lick` col (original lick column, most likely "con_lick")
    '''

    bout_type = f'{state.lower()[:3]}_lick' # references columns generated by `classify_lick_state`
    
    if len(lick_pos)>1:
        lick_pos = sorted(lick_pos)[::-1] # reverse sort licks to pull so counting after dropping doesn't get messed up

    t_ = timeseries.copy()
    for nth_lick in lick_pos: # iterate over licks to pull, starting with later licks first
        new_col = '_'.join([bout_type, str(nth_lick)]) # name new column as `[STATE]_[Nth_LICK]`
        t_[new_col] = 0 # zero outside of licks
        lick_subset = t_.loc[t_[bout_type]==1].copy() # take only rows where lick bouts in `state` occurred
        t_.loc[lick_subset.groupby('nTrial', as_index=False).nth(nth_lick-1).index, new_col] = 1 # set nth lick to value 1
        t_.loc[lick_subset.groupby('nTrial', as_index=False).nth(nth_lick-1).index, bout_type] = 0 # reset these licks to zero in original column
    
    if keep_only_nth_lick:
        t_.drop(columns=[bout_type], inplace=True) # drop original column

    return t_


def event_interactions_dummies(timeseries, trials, states, trial_type, as_dummy=True, drop_non_interaction=True):

    '''
    define interaction terms to further classify lick identities based on behavior/task variables
    ARGUMENTS:
        - timeseries (pandas DF): timeseries of aligned behavior and photometry data; expects licks labeled in states
        - trials (pandas DF): trial-based information about behavior/task events that can be mapped to timeseries
        - states (list): list of lick-states to interact with trial variables
        - trial_type (str): column to interact with lick-states (e.g. 'Reward' or 'h2')
        - as_dummy (bool): if True, create dummy variables for each value in `trial_type` column;
                           if False (only in case of binary variable), symmetric representation for 1s and 0s
        - drop_non_interaction (bool): if True, drop original lick column and leave only interaction term
    OUTPUTS:
        - t_ (pandas DF): copied from `timeseries`, with new columns for interaction terms
    
    
    '''

    t_ = timeseries.copy()
    licks_to_interact = [state.lower()[:3] for state in states] # list of states formatted as from `classify_lick_state`
    licks_to_interact = '|'.join(licks_to_interact) # argument for regex search joined by | conditional
    t_ = t_.filter(regex=(licks_to_interact)) # filter timeseries by columns containing lick-states to interact
    
    cols_to_interact = t_.columns # store list of interaction lick columns
    cols_for_later = [col for col in timeseries.columns if col not in t_.columns] # store columns to add back in after interacting (e.g. `nTrial`)

    if as_dummy:
        dummies = pd.get_dummies(trials[trial_type], prefix=trial_type) # create dummy columns for each value in `trial_type`
    else:
        dummes = trials[[trial_type]] # same form as dummies but just a df with `trial_type` column; index is `nTrial`

    for dummy_col in dummies.columns:
        trial_type_ts = timeseries['nTrial'].map(dummies[dummy_col]) # map `trial_type` to timeseries (len=len(timeseries)) 

        # list new column names as "[TRIAL_TYPE_CLASS]_[TRIAL_TYPE_DUMMY]_[ORIGINAL_LICK_COL_NAME]"
        new_cols = [f'{trial_type.lower()[:3]}_{dummy_col.split("_")[-1]}_{col}' for col in cols_to_interact]

        # interact (multiply) dummy variable with all specified lick columns
        t_[new_cols] =  t_[cols_to_interact].multiply(trial_type_ts, axis='index')

    if drop_non_interaction:
        t_ = t_.drop(columns=cols_to_interact) # drop original lick columns 
    t_[cols_for_later] = timeseries[cols_for_later].copy() # add columns to final df that weren't interacted but should be kept
    
    return t_


def add_heatmap_columns(timeseries, trials):

    t_ = timeseries.copy()

    t_['hm_t_cue_offset_to_sel'] = t_['nTrial'].map(trials['tSelection'])

    cue_onset_times = t_['nTrial'].map(t_.loc[t_.Cue==1].groupby('nTrial')['trial_clock'].first())
    t_['hm_t_from_cue_onset'] = t_['trial_clock'] - cue_onset_times

    cons_onset_times = t_['nTrial'].map(t_.loc[t_.Consumption==1].groupby('nTrial')['trial_clock'].first())
    t_['hm_t_from_cons_onset'] = t_['trial_clock'] - cons_onset_times

    consumption_lengths = t_.groupby('nTrial', as_index=False).agg({'Consumption':np.sum, 'stateConsumption':np.sum})
    consumption_lengths['t_sel_to_cons'] = (consumption_lengths.stateConsumption - consumption_lengths.Consumption) * (1000/50)

    t_['hm_t_sel_to_cons'] = t_['nTrial'].map(consumption_lengths.set_index('nTrial')['t_sel_to_cons'])
    t_['hm_t_cue_offset_to_cons'] = t_['hm_t_sel_to_cons'] +  t_['hm_t_cue_offset_to_sel'] #t_['nTrial'].map(trials['tSelection'])

    return t_[[col for col in t_.columns if str(col).startswith('hm')]]

def make_design_mat(timeseries, trials, states=None, nth_licks=None,
                    interactions=None):


    '''
    wrapper to generate design matrix with desired features classifying each lick
    ARGUMENTS:
        - timeseries (pandas DF): timeseries of aligned behavior and photometry data
        - trials (pandas DF): trial-based information about behavior/task events that can be mapped to timeseries
        - states (list of str): states to define licks by (will only keep licks in specified states)
        - nth_licks (list of int): lick index in bout to isolate from bout; i.e., to take only first lick -> [1]
        - interactions (None or dict): sublists contents trial_type:states are types of features to interact
    OUTPUTS:
        - design mat (pandas DF): matrix with N rows for timepoints across session and M columns for features (each lick uniquely classified)
    
    TO-DO: currently only functional for cases where lick gets pulled from bout; add option to include whole original bout
    '''

    if states is None:
        states = ['Select','Consumption', 'ENLP'] # states to include licks within; Cue will automatically be included

    if nth_licks is None:
        nth_licks = [1] # default behavior is take only first lick

    trials = trials.set_index('nTrial') # for mapping to timeseries
    trials = trials.convert_dtypes()

    orig_cols = timeseries.columns # keep track of original columns to drop later?
    photo_columns = [col for col in orig_cols if 'z_grn' in col] # note photometry columns to add back later

    hm_columns = add_heatmap_columns(timeseries, trials)

    timeseries['Lick'] = (~np.isnan(timeseries.iSpout)).astype('int') # make column with 1s where licks occurred
    # timeseries = timeseries.rename(columns={'Cue':'cue'}) # to match lowercase of other states

    timeseries = classify_lick_state(timeseries, states) # classify all licks by state

    lick_cols = [col for col in timeseries.columns if '_lick' in col] # get column names for lick states

    timeseries['time_from_enl_onset'] = 0 # initialize column with 0 outside of ENL period
    timeseries['time_from_enlp_onset'] = 0 # initialize column with 0 outside of ENL period preceding a penalty

    # set counter for time within ENL onset (can be linear or exponential); option to add: can also step forward past ENL period
    timeseries.loc[((timeseries.ENL==1) | (timeseries.Cue==1)), 'time_from_enl_onset'] = (timeseries.loc[((timeseries.ENL==1) | (timeseries.Cue==1))].groupby('nTrial').cumcount()**2) / (50*100) 
    timeseries.loc[timeseries.state_ENLP==1 , 'time_from_enlp_onset'] = (timeseries.loc[timeseries.state_ENLP==1].groupby(['nTrial', 'nENL']).cumcount()**2) / (50*100) 

    # get indices of cue onset rows
    cue_onsets = timeseries.loc[timeseries.Cue==1].groupby('nTrial', as_index=False).nth(0).index.values

    design_mat = (timeseries[lick_cols 
                    + ['nTrial', 'iBlock', 'time_from_enl_onset', 'time_from_enlp_onset'] 
                    + photo_columns
                    # + hm_columns
                    ].copy()) # new timeseries only containing licks and essential trial IDs
    design_mat['cue'] = 0 # name to match lowercase of other states; initialize non-cue states as 0
    design_mat.loc[cue_onsets, 'cue'] = 1 # only 1 where cue onset occurred (even though duration of 75 or 80 ms)

    design_mat = pull_lick_from_bout(design_mat, nth_licks, keep_only_nth_lick=True) # split licks by ith position in bout (dummies)

    if interactions:
        
        design_mat['flag'] = 0 # column for any NaNs in trial type (should include timeouts)
        
        for trial_type, s_ in interactions.items():
            design_mat['flag'] += design_mat['nTrial'].map(trials[trial_type].isna())
            design_mat = event_interactions_dummies(design_mat, trials, states=s_, trial_type=trial_type)

    design_mat[hm_columns.columns] = hm_columns
    design_mat['flag'] = design_mat['flag'].clip(0,1) # design_mat['nTrial'].map(trials['timeout'])

    dummies = [col for col in design_mat.columns if col.endswith('cue')]
    # Still unknown: why would a few trials be missing a cue?
    meet_dummy_criteria = design_mat.groupby('nTrial')[dummies].sum().sum(axis=1)
    trials_without_dummies = meet_dummy_criteria.loc[meet_dummy_criteria==0].index.values
    print(f'{trials_without_dummies = }')
    design_mat.loc[design_mat.nTrial.isin(trials_without_dummies), 'flag'] = 1

    return design_mat
